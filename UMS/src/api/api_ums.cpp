/**
 * \file api_ums.cpp
 * \brief This file contains the VISHNU api functions.
 * \authors Daouda Traore (daouda.traore@sysfera.com) and Ibrahima Cisse (ibrahima.cisse@sysfera.com)
 */

#include "api_ums.hpp"

using namespace std;

/**
 * \brief Function to open a session 
 * \fn int connect(const std::string& userId, 
 *                 const std::string& password, 
 *                 std::string& sessionKey(), 
 *                 const UMS_Data::ConnectOptions& connectOpt=UMS_Data::ConnectOptions())
 * \param userId The VISHNU user identifier
 * \param password The password of the user
 * \param sessionKey The encrypted identifier of the session generated by VISHNU 
 * \param connectOpt To encapsulate the options available for the connect method. It allows the user 
 *  to choose the way for way for closing the session automatically on TIMEOUT or on DISCONNECT and the
 *  possibility for an admin to open a session as she was a specific user
 *  \return raises an exception on error
 */
int 
connect(const string& userId, 
        const string& password, 
        string& sessionKey, 
        const UMS_Data::ConnectOptions& connectOpt) 
                                                  throw(SystemException) 
{

  if((connectOpt.getClosePolicy() < 0) || (connectOpt.getClosePolicy() > 2)) {
     throw std::runtime_error("Invalid ClosePolicy value: its value must be 0, 1 or 2");
  }

  UserProxy userProxy(userId, password);
  SessionProxy sessionProxy;
  int res = sessionProxy.connect(userProxy, connectOpt);

  sessionKey = sessionProxy.getData().getSessionKey();

  std::string envValue = "export VISHNU_SESSION_KEY="+sessionKey;
  std::cout << envValue << endl;
 
 return res;
}

/**
 * \brief Function to return the sessionKey of a session in which the user was disconnected previously without closing it
 * \fn int reconnect(const std::string& userId, 
 *                   const std::string& password, 
 *                   const std::string& sessionId, 
 *                   std::string& sessionKey) 
 * \param userId represents the VISHNU user identifier
 * \param password represents the password of the user
 * \param sessionId is the identifier of the session defined in the database
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \return raises an exception on error
 */
int 
reconnect(const string& userId, 
          const string& password, 
          const string& sessionId, 
          string& sessionKey) 
                            throw(SystemException)
{

  UserProxy userProxy(userId, password);
  UMS_Data::Session session;
  session.setSessionId(sessionId);
  SessionProxy sessionProxy(session);

  int res = sessionProxy.reconnect(userProxy);

  sessionKey = sessionProxy.getData().getSessionKey();

  std::string envValue = "export VISHNU_SESSION_KEY="+sessionKey;
  std::cout << envValue << endl;

 return res;
}

/**
 * \brief Function to close the session identfied by the session key
 * \fn int close(const std::string& sessionKey) 
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \return raises an exception on error 
 */
int 
close(const string&  sessionKey) 
                               throw(SystemException)
{

 return SessionProxy(sessionKey).close();;

}

/**
 * \brief Function to add a new user in VISHNU
 * \fn int addUser(const std::string& sessionKey,
 *                 const UMS_Data::User& newUser)
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU 
 * \param newUser is an object containing the new user information
 * \return raises an exception on error 
 */
int 
addVishnuUser(const string& sessionKey, const UMS_Data::User& newUser) 
                                                                     throw(SystemException)
{

  if((newUser.getPrivilege() < 0) || (newUser.getPrivilege() > 1)) {
     throw std::runtime_error("Invalid Privilege value: its value must be 0 or 1");
  }
 
  SessionProxy sessionProxy(sessionKey);
  UserProxy userProxy(sessionProxy);

 return userProxy.add(newUser);
}

/**
 * \brief Function to update the user information except the userId and the password
 * \fn int updateUser(const std::string& sessionKey, 
 *                    const UMS_Data::User& user)
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU 
 * \param user is an object containing the new user information
 * \return raises an exception on error 
 */
int 
updateUser(const string& sessionKey, 
           const UMS_Data::User& user) 
                                     throw(SystemException)
{
 
   if((user.getPrivilege() < 0) || (user.getPrivilege() > 1)) {
     throw std::runtime_error("Invalid Privilege value: its value must be 0 or 1");
   }

   SessionProxy sessionProxy(sessionKey);
   UserProxy userProxy(sessionProxy);

  return userProxy.update(user);
}

/**
 * \brief Function to remove a user from VISHNU
 * \fn int deleteUser(const std::string& sessionKey,
 *                    const std::string& userId) 
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param userId represents the VISHNU user identifier of the user who will be deleted from VISHNU
 * \return raises an exception on error 
 */
int 
deleteUser(const string& sessionKey, 
           const string& userId)
                               throw(SystemException)
{


  UMS_Data::User user;
  user.setUserId(userId);
  SessionProxy sessionProxy(sessionKey);
  UserProxy userProxy(sessionProxy);

 return userProxy.deleteUser(user);
}

/**
 * \brief Function to change the password
 * \fn int changePassword(const std::string& userId,
 *                        const std::string& password, 
 *                        const std::string& passwordNew) 
 * \param userId represents the VISHNU user identifier
 * \param password represents the password of the user
 * \param passwordNew represents the new password of the user
 * \return raises an exception on error 
 */
int
changePassword(const std::string& sessionKey, 
               const std::string& password, 
               const std::string& passwordNew)
                                             throw(SystemException) 
{

  SessionProxy sessionProxy(sessionKey);
  UserProxy userProxy(sessionProxy);

 return userProxy.changePassword(password, passwordNew);
}

/**
 * \brief Function to reset the password of a user
 * \fn int resetPassword(const std::string& sessionKey, 
 *                       const std::string& userId) 
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param userId represents represents the VISHNU user identifier of the user whose password will be reset
 * \return raises an exception on error 
 */
int
resetPassword(const std::string& sessionKey, 
              const std::string& userId) 
                                       throw(SystemException)
{

  UMS_Data::User user;
  user.setUserId(userId);
  SessionProxy sessionProxy(sessionKey);
  UserProxy userProxy(sessionProxy);

 return userProxy.resetPassword(user);
}

/**
 * \brief Function to add a new machine in VISHNU
 * \fn int addMachine(const std::string& sessionKey, 
 *                    const UMS_Data::Machine& newMachine) 
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param newMachine is an object which encapsulates the information of the machine which will be added in VISHNU except the
 * machine id which will be created automatically by VISHNU
 * \return raises an exception on error 
 */
int 
addMachine(const std::string& sessionKey, 
           const UMS_Data::Machine& newMachine) 
                                              throw(SystemException)
{

  if((newMachine.getStatus() < 0) || (newMachine.getStatus() > 1)) {
    throw std::runtime_error("Invalid Status value: its value must be 0 or 1");
  }

  SessionProxy sessionProxy(sessionKey);
  MachineProxy machineProxy(newMachine, sessionProxy);

 return machineProxy.add();
}

/**
 * \brief Function to update machine description 
 * \fn int updateMachine(const std::string& sessionKey, 
 *                       const UMS_Data::Machine& machine) 
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param machine is an existing machine information
 * \return raises an exception on error 
 */
int 
updateMachine(const std::string& sessionKey,
              const UMS_Data::Machine& machine) 
                                              throw(SystemException)
{

  if((machine.getStatus() < 0) || (machine.getStatus() > 1)) {
    throw std::runtime_error("Invalid Status value: its value must be 0 or 1");
  }

  SessionProxy sessionProxy(sessionKey);
  MachineProxy machineProxy(machine, sessionProxy);

 return machineProxy.update();
}

/**
 * \brief Function to remove a machine from VISHNU
 * \fn int deleteMachine(const std::string& sessionKey,
 *                       const std::string& machineId) 
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param machineId represents the identifier of the machine
 * \return raises an exception on error 
 */
int 
deleteMachine(const std::string& sessionKey,
              const std::string& machineId)
                                          throw(SystemException)
{

  UMS_Data::Machine machine;
  machine.setMachineId(machineId);
  SessionProxy sessionProxy(sessionKey);
  MachineProxy machineProxy(machine, sessionProxy);

 return machineProxy.deleteMachine();
}

/**
 * \brief Function to add a new local user configuration
 * \fn int addLocalAccount(const std::string& sessionKey,
 *                         const UMS_Data::LocalAccount& newLocalAccount, 
 *                         std::string&  sshPublicKey) 
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param newLocalAccount is is the object which encapsulates the new local user configuration
 * \param sshPublicKey the SSH public key generated by VISHNU for accessing a local account
 * \return raises an exception on error 
 */
int
addLocalAccount(const std::string& sessionKey, 
                const UMS_Data::LocalAccount& newLocalAccount, 
                std::string& sshPublicKey)
                                         throw(SystemException)
{

  SessionProxy sessionProxy(sessionKey);
  LocalAccountProxy localAccountProxy(newLocalAccount, sessionProxy);
  int res = localAccountProxy.add();
  sshPublicKey = localAccountProxy.getSshPublicKey(); 
 
  std::cout << "sshPublicKey = " << sshPublicKey << std::endl;
  
 return res;
}

/**
 * \brief Function to update a local user configuration
 * \fn int updateLocalAccount(const std::string& sessionKey, 
 *                            const UMS_Data::LocalAccount& localAccount) 
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param localAccount is an object which encapsulates the local user configuration changes except the machineId and the userId
 * \return raises an exception on error 
 */
int
updateLocalAccount(const std::string& sessionKey, 
                   const UMS_Data::LocalAccount& localAccount) 
                                                             throw(SystemException)
{

 SessionProxy sessionProxy(sessionKey);
 LocalAccountProxy localAccountProxy(localAccount, sessionProxy);

 return localAccountProxy.update();
}

/**
 * \brief Function to removes a local user configuration (for a given user on a given machine) from VISHNU
 * \fn int deleteLocalAccount(const std::string& sessionKey, 
 *                            const std::string& userId, 
 *                            const std::string& machineId) 
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param userId represents the VISHNU user identifier of the user whose local configuration will be deleted for the given machine
 * \param machineId represents the identifier of the machine whose local configuration will be deleted for the given user
 * \return raises an exception on error 
 */
int 
deleteLocalAccount(const std::string& sessionKey, 
                   const std::string& userId, 
                   const std::string& machineId) 
                                               throw(SystemException)
{

  UMS_Data::LocalAccount localAccount;
  localAccount.setUserId(userId);
  localAccount.setMachineId(machineId);
  SessionProxy sessionProxy(sessionKey);
  LocalAccountProxy localAccountProxy(localAccount, sessionProxy);

 return localAccountProxy.deleteLocalAccount();
}

/**
 * \brief Function to save the configuration of VISHNU
 * \fn int saveConfiguration(const std::string& sessionKey, 
 *                           const std::string& filePath,
 *                           UMS_Data::Configuration& config) 
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param config is an object which encapsulates the configuration description
 * \return raises an exception on error 
 */
int 
saveConfiguration(const std::string& sessionKey, 
                 UMS_Data::Configuration& config) 
                                                throw(SystemException)
{
 
   std::string filePath = std::string(getenv("HOME"))+"/.vishnu/toto.cfg"; 
   SessionProxy sessionProxy(sessionKey);
   ConfigurationProxy configurationProxy(filePath, sessionProxy);

   int res = configurationProxy.save();
 
   if(!res) {
     UMS_Data::Configuration *configData = configurationProxy.getData();
 
     UMS_Data::User_ptr user;
  
     //To set the user list 
     for(int i = 0; i < configData->getListConfUsers().size(); i++) {
       user = configData->getListConfUsers().get(i);
       config.getListConfUsers().push_back(user);
     }
     //To set the machine list
     UMS_Data::Machine_ptr machine; 
     for(int i = 0; i < configData->getListConfMachines().size(); i++) {
       machine = configData->getListConfMachines().get(i);
       config.getListConfMachines().push_back(machine);
     }
     //To set the LocalAccounts list
     UMS_Data::LocalAccount_ptr localAccount; 
     for(int i = 0; i < configData->getListConfLocalAccounts().size(); i++) {
       localAccount = configData->getListConfLocalAccounts().get(i);
       config.getListConfLocalAccounts().push_back(localAccount);
     }
  }

  return res;
}

/**
 * \brief Function to restore the configuration of VISHNU
 * \fn int restoreConfiguration(const std::string& sessionKey, 
 *                              const std::string& filePath) 
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param filePath is the path of the file used to restore VISHNU configuration
 * \return raises an exception on error 
 */
int 
restoreConfiguration(const std::string& sessionKey, 
                     const std::string& filePath) 
                                                throw(SystemException)
{

   SessionProxy sessionProxy(sessionKey);
   ConfigurationProxy configurationProxy(filePath, sessionProxy);

 return configurationProxy.restoreFromFile();
}

/**
 * \brief Function to configure an option of the user
 * \fn int configureOption(const std::string& sessionKey, 
 *                         const UMS_Data::OptionValue& optionValue) 
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param optionValue is an object which encapsulates the option information
 * \return raises an exception on error 
 */
int
configureOption(const std::string& sessionKey, 
                const UMS_Data::OptionValue& optionValue) 
                                                        throw(SystemException)
{
 
  SessionProxy sessionProxy(sessionKey);
  OptionValueProxy optionValueProxy(optionValue, sessionProxy);

 return optionValueProxy.configureOption();
}

/**
 * \brief Function to configure a default option value
 * \fn int configureDefaultOption(const std::string& sessionKey,
 *                                const UMS_Data::OptionValue& optionValue) 
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param optionValue is an object which encapsulates the option information
 * \return raises an exception on error 
 */
int
configureDefaultOption(const std::string& sessionKey, 
                       const UMS_Data::OptionValue& optionValue) 
                                                               throw(SystemException)
{

  SessionProxy sessionProxy(sessionKey);
  OptionValueProxy optionValueProxy(optionValue, sessionProxy);

 return optionValueProxy.configureDefaultOption();
}

/**
 * \brief Function to list all sessions of the user
 * \fn int listSessions(const std::string& sessionKey,
 *                      UMS_Data::ListSessions& listSession,
 *                      const UMS_Data::ListSessionOptions& options) 
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param listSession is an object which encapsulates the list of sessions
 * \param options allows the user to list sessions using several optional criteria such as: the state of sessions (actives or
 * inactives, by default, all sessions are listed), a period, a specific session or for admin to list all sessions of all
 * users or sessions of a specific user.
 * \return raises an exception on error 
 */
int 
listSessions(const std::string& sessionKey, 
             UMS_Data::ListSessions& listSession,
             const UMS_Data::ListSessionOptions& options)
                                                        throw(SystemException)
{


  if((options.getSessionClosePolicy() < 0) || (options.getSessionClosePolicy() > 2)) {
       throw std::runtime_error("Invalid ClosePolicy value: its value must be 0, 1 or 2");
  }

  if((options.getStatus() < 0) || (options.getStatus() > 1)) {
       throw std::runtime_error("Invalid Privilege value: its value must be 0 or 1");
  }
   
  SessionProxy sessionProxy(sessionKey);
  QueryProxy<UMS_Data::ListSessionOptions, UMS_Data::ListSessions> query(options, sessionProxy, "sessionList");

  UMS_Data::ListSessions* listSession_ptr = query.list();  

  if(listSession_ptr!=NULL) {
    UMS_Data::Session_ptr session;
    for(int i = 0; i < listSession_ptr->getSessions().size(); i++) {
      session = listSession_ptr->getSessions().get(i);
      listSession.getSessions().push_back(session);
    }
  } 
  else {
    return 1;
  }

 return 0;
}

/**
 * \brief Function to list the local user configurations
 * \fn int listLocalAccount(const std::string& sessionKey,
 *                          UMS_Data::ListLocalAccounts& listLocalAcc,
 *                          const UMS_Data::ListLocalAccOptions& options) 
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param listLocalAcc is an object which encapsulates the list of the local user configuations
 * \param options allows an admin to list all local configurations of all users or a simple user to list his/her local user configurations on a 
 * specific machine
 * \return raises an exception on error 
 */
int
listLocalAccount(const std::string& sessionKey, 
                 UMS_Data::ListLocalAccounts& listLocalAcc,
                 const UMS_Data::ListLocalAccOptions& options)
                                                             throw(SystemException)
{

  SessionProxy sessionProxy(sessionKey);
  QueryProxy<UMS_Data::ListLocalAccOptions, UMS_Data::ListLocalAccounts> query(options, sessionProxy, "localAccountList");

  UMS_Data::ListLocalAccounts* listLocalAcc_ptr = query.list();

  if(listLocalAcc_ptr!=NULL) {
    UMS_Data::LocalAccount_ptr account;
    for(int i = 0; i < listLocalAcc_ptr->getAccounts().size(); i++) {
      account = listLocalAcc_ptr->getAccounts().get(i);
      listLocalAcc.getAccounts().push_back(account);
    }
  }
  else {
   return 1;
  }

  return 0;
}

/**
 * \brief Function to list the machines in which the local user configurations are defined for the given user
 * \fn int listMachine(const std::string& sessionKey,
 *                     UMS_Data::ListMachines& listMachine,
 *                     const UMS_Data::ListMachineOptions& options) 
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param listMachine is an object which encapsulates the list of the machines 
 * \param options allows a user to list all VISHNU machines or information about a specific machine and an admin to list machines used by 
 * a specific user
 * \return raises an exception on error 
 */
int
listMachine(const std::string& sessionKey, 
            UMS_Data::ListMachines& listMachine,
            const UMS_Data::ListMachineOptions& options)
                                                       throw(SystemException)
{

  SessionProxy sessionProxy(sessionKey);
  QueryProxy<UMS_Data::ListMachineOptions, UMS_Data::ListMachines> query(options, sessionProxy, "machineList");

  UMS_Data::ListMachines* listMachine_ptr = query.list();

  if(listMachine_ptr!=NULL) {
  UMS_Data::Machine_ptr machine;
  for(int i = 0; i < listMachine_ptr->getMachines().size(); i++) {
    machine = listMachine_ptr->getMachines().get(i);
    listMachine.getMachines().push_back(machine);
  }
  }
  else {
    return 1;
  }

  return 0;
}

/**
 * \brief Function to list the commands
 * \fn int listHistoryCmd(const std::string& sessionKey,
 *                        UMS_Data::ListCommands& listCommands,
 *                        const UMS_Data::ListCmdOptions& options) 
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param listCommands is an object which encapsulates the list of commands
 * \param options allows the user to list commands by using several optional criteria: a period, specific session and for admin
 * to list all commands of all VISHNU users or commands from a specific user
 * \return raises an exception on error 
 */
int
listHistoryCmd(const std::string& sessionKey, 
               UMS_Data::ListCommands& listCommands,
               const UMS_Data::ListCmdOptions& options)
                                                      throw(SystemException)
{

  SessionProxy sessionProxy(sessionKey);
  QueryProxy<UMS_Data::ListCmdOptions, UMS_Data::ListCommands> query(options, sessionProxy, "commandList");

  UMS_Data::ListCommands* listCommands_ptr = query.list();

  if(listCommands_ptr!=NULL) {
    UMS_Data::Command_ptr command;
    for(int i = 0; i < listCommands_ptr->getCommands().size(); i++) {
      command = listCommands_ptr->getCommands().get(i);
      listCommands.getCommands().push_back(command);
    }
  }
  else {
    return 1;
  }

  return 0;
}

/**
 * \brief Function to list the options of the user
 * \fn int listOptions(const std::string& sessionKey,
 *                     UMS_Data::ListOptionsValues& listOptValues,
 *                     const UMS_Data::ListOptOptions& options) 
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param listOptValues is an object which encapsulates the list of options
 * \param options allows to list a specific option or all default options values or for an admin to list options of a specific user
 * \return raises an exception on error 
 */
int
listOptions(const std::string& sessionKey, 
            UMS_Data::ListOptionsValues& listOptValues,
            const UMS_Data::ListOptOptions& options)
                                                   throw(SystemException)
{

  SessionProxy sessionProxy(sessionKey);
  QueryProxy<UMS_Data::ListOptOptions, UMS_Data::ListOptionsValues> query(options, sessionProxy, "optionValueList");

  UMS_Data::ListOptionsValues* listOptValues_ptr = query.list();

  if(listOptValues_ptr!=NULL) {
    UMS_Data::OptionValue_ptr optionValue;
    for(int i = 0; i < listOptValues_ptr->getOptionValues().size(); i++) {
      optionValue = listOptValues_ptr->getOptionValues().get(i);
      listOptValues.getOptionValues().push_back(optionValue);
    }
  }
  else {
    return 1;
  }

  return 0;
}

/**
 * \brief Function to list VISHNU users
 * \fn int listUsers(const std::string& sessionKey,
 *                   UMS_Data::ListUsers& listUsers,
 *                   const std::string& userIdOption) 
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param listUsers is an object which encapsulates the list of users
 * \param options allows an admin to get information about a specific user identified by his/her userId
 * \return raises an exception on error 
 */
int 
listUsers(const std::string& sessionKey, 
          UMS_Data::ListUsers& listUsers, 
          const std::string& userIdOption)
                                         throw(SystemException)
{

  SessionProxy sessionProxy(sessionKey);
  QueryProxy<std::string, UMS_Data::ListUsers> query(userIdOption, sessionProxy, "userList");

  UMS_Data::ListUsers* listUsers_ptr = query.listWithParamsString();

  if(listUsers_ptr!=NULL) {
    UMS_Data::User_ptr user;
    for(int i = 0; i < listUsers_ptr->getUsers().size(); i++) {
      user = listUsers_ptr->getUsers().get(i);
      listUsers.getUsers().push_back(user);
    }
  }
  else {
    return 1;
  }
 
 return 0;
}

/**
 * \brief Function to initialize the SYSFERA-DS configuration
 * \fn int vishnuInitialize(char* cfg, int argc, char** argv)
 * \param cfg The SYSFERA-DS configuration file
 * \param argc The number of arguments of the program 
 * \param argv The list of arguments
 * \return an error code 
 */
int 
vishnuInitialize(char* cfg, int argc, char** argv) {
 
  return UtilsProxy(cfg, argc, argv).initilialize();
}

/**
 * \brief Function to finalize 
 * \fn int vishnuFinalize() 
 * \return an error code  
 */
void
vishnuFinalize() {

   UtilsProxy().finalize();
}

/**
 * \brief Function to initialize the database 
 * \fn  int restore()
 * \param filePath the file
 * \return an error code
 */
int
restore(const std::string& filePath) {
  
  return UtilsProxy(filePath).restore();
}
